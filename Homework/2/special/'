%% Constants
global J k_t k_b N R L b m g l
J = .02;
k_t = .01;
k_b = k_t;
N = 10;
R = 2;
L = .5;
b = .2;
m = 1;
g = 10;
l = .3;

%% Script
%% Part a)
% Finding equilibrium points
for i = [15, 21.2, 30, 40, 75]
    fprintf("Equilibrium for u(t) = %f\n", i)
    tmp = equilibrium_constant(i);
    fprintf("x_1: %g + %gi\nx_2: %g + %gi\nx_3: %g + %gi\n", real(tmp(1)), imag(tmp(1)),real(tmp(2)), imag(tmp(2)),real(tmp(3)), imag(tmp(3)));
end


%% Part b)
% For accessing the linear system cells

linear_systems = {};
for i = [15, 45]
    fprintf("Linearization for u(t) = %f\n", i)
    [A B C D] = linearize(i);
    linear_systems{end+1} = {ss(A, B, C, D), equilibrium_constant(i), i};
end



%% Part c)
t = 0:0.005:2;
u = zeros(size(t));
system_conditions = {{10, [pi/2 0 0]},{21.2, [0 0 0]},{21.2, [pi/4 0 0]},{21.2, [pi/3 0 0]},{21.2, [pi/2 0 0]},{30, [-pi/2 0 0]},{30, [0 0 0]}};
for cond = system_conditions
    for sys = linear_systems
        u(:,:) = cond{1}{1} - sys{1}{3};
        y = lsim(sys{1}{1}, u, t, cond{1}{2} - sys{1}{2}.'); % some issue here with inital conditions.....
        plot(t, y(:,1) + sys{1}{2}(1), "b");
        plot_title = sprintf("lsim of system linearized around input = %f \n u(t) = %f  x_0 = %f", sys{1}{3}, cond{1}{1}, cond{1}{2}(1));
        title(plot_title);
        xlabel("Time");
        ylabel("Angle in radians");
        filename = sprintf("images/linearized_%f_input_%f_initial_pos_%f.png", sys{1}{3}, cond{1}{1}, cond{1}{2}(1));
        saveas(gcf, filename);
    end
end
% TODO: the delta x part doesn't happen....

%% Pard d)
system_conditions = {{10, [pi/2 0 0]},{21.2, [0 0 0]},{21.2, [pi/4 0 0]},{21.2, [pi/3 0 0]},{21.2, [pi/2 0 0]},{30, [-pi/2 0 0]},{30, [0 0 0]}};
for cond = system_conditions
    [ts, y] = ode45(@(t,x) dx(x, @(x) cond{1}{1}, t), [t(1) t(end)], cond{1}{2});
    plot(ts, y(:,1), "r");
    hold on

    u(:,:) = cond{1}{1} - linear_systems{1}{3};
    y = lsim(linear_systems{1}{1}, u, t, cond{1}{2} - linear_systems{1}{2}.');
    plot(t, y(:,1) + linear_systems{1}{2}(1), "b");
    u(:,:) = cond{1}{1} - linear_systems{2}{3};
    y = lsim(linear_systems{2}{1}, u, t, cond{1}{2} - linear_systems{2}{2}.');
    plot(t, y(:,1) + linear_systems{2}{2}(1), "g");
    legend("location", "best");
    legend("ode45","Linearized (u(t)=15)", "Linearized (u(t)=45)");
    
    plot_title = sprintf("Comparison of lsim to ode45 \n u(t) = %f  x_0 = %f", cond{1}{1}, cond{1}{2}(1));
    title(plot_title);
    xlabel("Time");
    ylabel("Angle in radians");
    
    filename = sprintf("images/input_%f_initial_pos_%f_vs_ode45.png", cond{1}{1}, cond{1}{2}(1));
    saveas(gcf, filename);
    hold off
end

%% Part f
% for functions see the bottom of the functions section
system_conditions = {{10, [pi/2 0 0]},{21.2, [0 0 0]},{21.2, [pi/4 0 0]},{21.2, [pi/3 0 0]},{21.2, [pi/2 0 0]},{30, [-pi/2 0 0]},{30, [0 0 0]}};
t = 0:0.01:5;
for cond = system_conditions
    y = sim_rect(@(t,x) dx(x, @(x) cond{1}{1}, t), t, cond{1}{2});
    plot(t, y(:,1), "g");
    [ts, y] = ode45(@(t,x) dx(x, @(x) cond{1}{1}, t), [t(1) t(end)], cond{1}{2});
    hold on
    plot(ts, y(:,1), "r");
    hold off
end




%% Functions
function x_dot = dx(x,func_impulse, t)
    global J k_t k_b N R L b m g l
    % dx_1 = x_2
    % dx_2 = (1/J) * (N*k_t*x_3-b*x_2-m*g*l*sin(x_1))
    % dx_3 = (1/L) * (u(t) - R*x_3-k_b*N*x_2)
    x_dot = [
        x(2);
        (1/J) * (N*k_t*x(3)-b*x(2)-m*g*l*sin(x(1)))
        (1/L) * (func_impulse(t) - R*x(3)-k_b*N*x(2))
    ];
end

% returns the equilibrium given a constant input function
function eq = equilibrium_constant(u_t)
    global J k_t k_b N R L b m g l
    eq = [
    asin((N*k_t*u_t)/(R*m*g*l));
    0;
    u_t/R;
    ];
end

% Linearize given an constant input function
function [A B C D] = linearize(u_t)
    global J k_t k_b N R L b m g l
    eq = equilibrium_constant(u_t);
    A = [
    0 1 0;
    -m*g*l*cos(eq(1))/J -b/J N*k_t/J;
    0 -k_b*N/L -R/L;
    ];
    B = [
    0;
    0;
    1/L;
    ];
    C = [
    1 0 0;
    0 0 0;
    0 0 0;
    ];
    D = [0];
end

% Approximate the simulations using the rectangular method of integration
function y = sim_rect(func_derivative_t_x, t, initial_condition)
    % Allocate space for all the results
    y = zeros(size(t,2),3);
    y(1, :) = initial_condition;
    for i = 2:size(y,1)
        dt = t(i)-t(i-1);
        y(i,:) = y(i-1,:).' + func_derivative_t_x(t(i), y(i-1,:))*dt;
    end
end

% Approximate the simulations using the rectangular method of integration
function y = sim_trap(func_derivative_t_x, t, initial_condition)
    % Allocate space for all the results
    y = zeros(size(t,2),3);
    y(1, :) = initial_condition;
    deriv_prev = func_derivative_t_x(t(1), y(1,:));
    for i = 2:size(y,1)
        deriv_cur = func_derivative_t_x(t(i), y(i-1,:));
        dt = t(i)-t(i-1);
        y(i,:) = y(i-1,:).' + dt;
    end
end
